---
title: __R Code Logistische Regression__
author: "Xuan Son Le (4669361), Freie Universität Berlin"
date: "04/04/2018"
output: 
  ptestData_document: 
    keep_tex: yes
    latex_engine: ptestDatalatex
    number_sections: yes
    toc: yes
    toc_depth: 3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

1. Datensatz einlesen

```{r Datendatz einlesen}
testData <- read.csv("https://stats.idre.ucla.edu/stat/data/binary.csv")
testData <- testData[1:100,]
testData$rank <- factor(testData$rank)
testModell <- as.formula("admit ~ gre + gpa + rank")
testModelFrame <- model.frame(testModell, testData)
```

2. Maximum Likelihood Schätzung

```{r Maximum Likelihood Schätzung}

calculate_p <- function(X, y, beta) {
    
    eta <- X %*% beta

    exp_eta <- exp(eta)

    p <- exp_eta / (1 + exp_eta)
    
    return(as.vector(p))
}


# loglike <- function(X, y, beta) {
#     
#     eta <- X %*% beta #
# 
#     exp_eta <- exp(eta) # 
#     
#     p <- exp_eta / (1 + exp_eta) # 
#     
#     result <- sum(crossprod(y,eta) - sum(log(1 + exp(eta))))
#     
#     return(result)
# }

maxLikeEst <- function(X, y, tolerance, maxIteration) {
    
    beta <- rep(0, times = ncol(X))
    
    M <- diag(nrow = nrow(X))

    #tolerance <- exp(-10)
    
    diff <- 10 * abs(tolerance)
    
    i <- 0

    while (diff > tolerance || i < maxIteration) {
            
            p <- calculate_p(X, y, beta)
            
            M <- diag(p * (1 - p))
            
            beta_change <- solve(t(X) %*% M %*% X) %*% t(X) %*% (y - p)
            
            beta <- beta + beta_change
            
            diff <- sum(abs(beta_change))
            
            i <- i + 1
    }

    dfRes <- nrow(X) - ncol(X)   # degrees of freedom = observations - params
    dfNull <- nrow(X) - 1 
        
    vcov <- solve(t(X) %*% M %*% X)  # compute cov matrix
    
    residualDeviance <- ((y - X %*% beta)) 

    result <- list(coefficients = beta,
                   vcov = vcov,
                   dfRes = dfRes,
                   residualDeviance = residualDeviance) 
    
    ### hier noch residuals, sigma,... berechnen
    
    return(result)
    
}

rawResult <- maxLikeEst(X = model.matrix(testModell, testModelFrame), 
                        y = model.response(testModelFrame), 
                        tolerance = exp(-20),
                        maxIteration = 5000)

```

3. Vergleich mit dem Standard Logit-Modell von R

```{r Standard Logit-Modell von R}
standardLogit <- stats::glm(testModell, family = binomial, data = testData)
str(standardLogit)

all(all.equal(standardLogit$coefficients, as.numeric(rawResult$coefficients),
              check.attributes = FALSE),
    all.equal(vcov(standardLogit), rawResult$vcov,
              check.attributes = FALSE, tolerance = exp(-5)),
    #all.equal(sigma(standardLogit), rawResult$sigma),
    all.equal(standardLogit$df.residual, rawResult$dfRes))

modelFrame <- model.frame(testModelFrame, testData)
X <- model.matrix(testModelFrame, modelFrame)
y <- model.response(modelFrame)
beta <- standardLogit$coefficients
as.numeric(y - X %*% beta)

```

4. Logistisches Modell manuell implementieren

```{r Manuelles Logit Modell}
logMod <- function(formula, data) {
    modelFrame <- model.frame(formula, data)
    X <- model.matrix(formula, modelFrame)
    y <- model.response(modelFrame)
    
    result <- maxLikeEst(X, y, tolerance = exp(-20), maxIteration = 5000)
    
    result$formula <- formula
    result$call <- match.call()
    
    class(result) <- "logMod"
    
    return(result)
    
}

logitModell <- logMod(formula = admit ~ gre + gpa + rank, data = testData)

```

5. S3 Methoden definieren

```{r S3 Print Methode}
print.logMod <- function(x, ...){
    
    cat("Call: ", paste0(deparse(x$call)), fill = TRUE)
    
    cat("\n\nCoefficients:\n")
    
    print.default(format(coef(x)[,1], digits = 4L),
                print.gap = 1L, quote = FALSE, right = TRUE)
    
    cat("\n\nDegrees of Freedom: ", x$dfNull, " Total (i.e. Null); ",
        x$dfFull, " Residual")
    
    #cat("\nNull Deviance:\t", nullDeviance)
    
    #cat("\nResidual Deviance:", resDeviance)
    
    # invisibly return linMod object
    invisible(x)

}

logitModell <- logMod(testModell, testData)
print(logitModell)
```

```{r S3 Summary Methode}

summary.logMod <- function(x, ...) {
    
    coef_standard_error <- sqrt(diag(x$vcov))
    
}
    
```

```{r Vergleichen}

nullModellGlm <- glm(formula = admit ~ 1, data = testData, family = binomial)
sum((nullModellGlm$residuals)^2)
vcov(nullModellGlm)   
deviance(nullModellGlm)

nullModell <- logMod(formula = admit ~ 1, data = testData)
nullModell$vcov 


modelFrame <- model.frame(as.formula(admit ~ 1), testData)
X <- model.matrix(as.formula(admit ~ 1), modelFrame)
y <- model.response(modelFrame)

maxLikeEst(X, y, tolerance = exp(-20), maxIteration = 5000)


```



